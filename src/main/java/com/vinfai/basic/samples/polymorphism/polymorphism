1.对方法 动态绑定
2.对属性 静态方法  静态绑定
http://www.cnblogs.com/zxsoft/archive/2007/08/18/860461.html
http://www.cnblogs.com/gnuhpc/archive/2013/01/04/2843655.html

动态绑定与静态绑定  当子类(Y)同时覆盖了父类(X)的属性和方法时，为什么“X s = new Y(); ”
这里的s只可以调用Y中覆盖X的方法，而不能使用Y中覆盖X的属性。这也是疑惑的关键。   
我先给出一个结论：父类引用指向子类对象时，父类与子类同名的属性和方法都会被覆盖。
（一般对属性的覆盖叫对属性的隐藏）   对于上面的结论我们来看你这个程序，既然属性可以被覆盖，
那怎么s.i是用了父类的变量值呢？这是关系到了java处理属性和方法的不同机制引起的。
   先再给出一个结论：java对方法的调用是采取动态绑定(运行时才判断)的方法，
   对属性的调用是采取静态绑定（编译时就判断）的方法。
      对于上面的结论我们来理解你的程序“X s = new Y(); ”，
      这一句，也可说是父类引用指向子类对象，也可以说是子类对象向上转型为父类引用。
      那在s使用属性的时候是静态绑定的，它是在编译期就决定了这个属性是属于哪一个类的对象了，
      所以在上面那句中的“X s”也就是说X类中的属性是用s来调用的，s就不能调用Y类中的属性，
      因为它是静态绑定了。而s使用方法时是动态绑定的
      ，所以s在调用方法的时候，java会去查看s这个时候的指向的对象是哪一个，是Y类对象就调用Y类的方法，
      是X类的对象就调用X类的方法。所以这里s是指向了Y类中的对象（“X s = new Y(); ”这句可知），
      则调用Y类中的方法。
      
      方法的重载，就是方法具有相同的名称，而参数列表不同，编译器可以根据参数的类型与个数加以区分，方法的返回类型与方法抛出的异常等因素的不同不作为重载的标准。
1.基本类型下重载方法的调用：在方法调用时，如果实参的类型与方法中形参的类型不相同，那么系统会调用形参类型可以兼容的实参类型，并且形参与实参类型最“亲密”的那个方法，也就是雨实参类型最接近的方法，所以方法调用中实参类型为char，而候选的方法中不存在形参类型为char，而分别为byte，short，int，long，float，double类型时，byte与shaort不能兼容char类型，不与考虑，剩下的4个类型类型中，int与char最为接近，此时会调用形参为int的方法。
2.引用类型下重载方法的调用：与基本数据类型的调用相似，形参与实参的参数列表不相同，而对应的形参类型可以兼容实参类型时，那么选择形参类型与实参类型兼容，并且与实参类型最接近的方法。比如爷爷，父亲，孙子的继承关系下，仅有父亲与爷爷为参数的方法，那么孙子对象就会调用父亲为形参的方法。
--第3点不理解........

3.重载无法实现多态：.对于引用类型参数的方法选择，是根据引用类型来决定调用哪个方法，与对象的类型没有关系，因为重载方法是在编译时确定的，也可以说“前期绑定”或“静态绑定。引用所指的对象类型在运行时才确定的，所以使用重载无法实现多态。”
3.

重载overload与覆盖override区别
